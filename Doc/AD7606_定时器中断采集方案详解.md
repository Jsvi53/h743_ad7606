# AD7606 定时器中断采集方案详解

## 一、方案1：定时器中断方式（bsp_spi_ad7606.c实现）

### 1.1 工作原理

**核心思想：流水线操作**
- 定时器频率 = ADC采样频率
- 在定时器中断中：**先读取上次转换结果，再启动下次转换**
- 实现转换和读取的并行处理

### 1.2 代码实现分析

#### 定时器中断服务程序

```c
void TIM4_IRQHandler(void)
{
    ad7606_IRQSrc();
}
```

#### 中断处理函数

```c
void ad7606_IRQSrc(void)
{
    uint8_t i;
    uint16_t usReadValue;

    TIM_ClearFlag(TIM4, TIM_FLAG_Update);

    /* 读取数据 
    示波器监测，CS低电平持续时间 35us 
    */
    AD_CS_LOW();
    for (i = 0; i < CH_NUM; i++)  // CH_NUM = 2（示例代码只读取2通道）
    {
        usReadValue = ad7606_ReadBytes();	
        if (g_tAD.usWrite < FIFO_SIZE)
        {
            g_tAD.usBuf[g_tAD.usWrite] = usReadValue;
            ++g_tAD.usWrite;
        }
    }		
    
    AD_CS_HIGH();	

    ad7606_StartConv();  // 启动下次转换
}
```

#### 启动转换函数

```c
void ad7606_StartConv(void)
{
    /* 上升沿开始转换，低电平持续时间至少25ns  */
    AD_CONVST_LOW();
    AD_CONVST_LOW();
    AD_CONVST_LOW();	/* 连续执行3次，低电平约50ns */
    
    AD_CONVST_HIGH();
}
```

### 1.3 时序分析

#### 关键时序点

```
定时器中断触发 (T0)
    ↓
读取上次转换结果 (T0 ~ T0+35μs)  ← 单DOUT读取8通道
    ↓
启动下次转换 (T0+35μs)
    ↓
CONVST上升沿 → BUSY变高 → 开始转换 (4μs)
    ↓
转换完成 → BUSY变低
    ↓
等待下次定时器中断 (T0+5μs for 200kSPS)
```

#### 问题分析

**单DOUT方案（当前代码）：**
- 读取8通道时间：**35μs**（代码注释实测值）
- 转换时间：4μs
- **总周期：max(35μs, 4μs) = 35μs**
- **最大采样频率：1/35μs ≈ 28.5 kSPS** ❌

**结论：单DOUT无法实现200kSPS！**

---

## 二、方案1优化：使用双DOUT + DMA

### 2.1 优化后的中断处理函数

```c
void ad7606_IRQSrc_Optimized(void)
{
    static uint16_t channels[8];
    
    TIM_ClearFlag(HTIMx, TIM_FLAG_Update);
    
    // 1. 读取上次转换的结果（使用双DOUT，约4-5μs）
    AD7606_ReadChannels_Dual(channels);
    
    // 2. 保存到FIFO（快速操作）
    for (int i = 0; i < 8; i++) {
        if (g_tAD.usWrite < FIFO_SIZE) {
            g_tAD.usBuf[g_tAD.usWrite++] = channels[i];
        }
    }
    
    // 3. 启动下次转换
    AD7606_StartConvst();
}
```

### 2.2 双DOUT读取函数（DMA方式）

```c
void AD7606_ReadChannels_Dual(uint16_t *channels)
{
    AD7606_CS_LOW();
    
    // 使用DMA并行读取
    HAL_SPI_Receive_DMA(&hspi1, (uint8_t*)&channels[0], 4);  // 通道1-4
    HAL_SPI_Receive_DMA(&hspi2, (uint8_t*)&channels[4], 4);  // 通道5-8
    
    // 等待传输完成
    while (HAL_SPI_GetState(&hspi1) != HAL_SPI_STATE_READY ||
           HAL_SPI_GetState(&hspi2) != HAL_SPI_STATE_READY);
    
    AD7606_CS_HIGH();
}
```

### 2.3 优化后的时序分析

**双DOUT + DMA方案：**
- 读取8通道时间：**4-5μs**（64个SCLK @ 15MHz）
- 转换时间：4μs
- 中断开销：约0.5-1μs
- **总周期：max(5μs, 4μs) + 1μs = 6μs**
- **最大采样频率：1/6μs ≈ 166 kSPS** ⚠️ **接近但略低于200kSPS**

**进一步优化（使用转换中读取）：**
- 读取可以在转换期间进行（流水线）
- **总周期：max(5μs, 4μs) = 5μs**
- **最大采样频率：1/5μs = 200 kSPS** ✅

---

## 三、方案1的关键要点

### 3.1 优点

1. ✅ **不需要BUSY信号**：简化硬件连接
2. ✅ **定时器精确控制**：采样频率由定时器决定，非常稳定
3. ✅ **流水线操作**：转换和读取可以并行
4. ✅ **代码简单**：逻辑清晰，易于理解

### 3.2 缺点

1. ⚠️ **中断开销**：每次中断都有响应时间
2. ⚠️ **中断嵌套问题**：如果其他中断优先级更高，可能影响采样周期
3. ⚠️ **单DOUT速度受限**：无法达到200kSPS

### 3.3 适用场景

**方案1适合：**
- ✅ 采样频率 ≤ 100kSPS（单DOUT）
- ✅ 采样频率 ≤ 200kSPS（双DOUT + 优化）
- ✅ 不需要BUSY信号的场景
- ✅ 对采样周期稳定性要求高的场景

**方案1不适合：**
- ❌ 单DOUT + 200kSPS（无法实现）
- ❌ 需要极低延迟的场景（中断有延迟）

---

## 四、200kSPS优化实现

### 4.1 完整的优化代码

```c
// 定时器中断服务程序（200kSPS优化版）
void TIMx_IRQHandler(void)
{
    static uint16_t channels[8];
    static uint8_t first_read = 1;
    
    TIM_ClearFlag(HTIMx, TIM_FLAG_Update);
    
    if (!first_read) {
        // 读取上次转换的结果（第一次调用时跳过，因为还没有数据）
        AD7606_ReadChannels_Dual(channels);
        
        // 快速保存到FIFO（使用循环缓冲区）
        for (int i = 0; i < 8; i++) {
            uint16_t write_idx = g_tAD.usWrite;
            if (write_idx < FIFO_SIZE) {
                g_tAD.usBuf[write_idx] = channels[i];
                g_tAD.usWrite = (write_idx + 1) % FIFO_SIZE;
            }
        }
    } else {
        first_read = 0;
    }
    
    // 启动下次转换（在读取完成后立即启动）
    AD7606_StartConvst();
}
```

### 4.2 初始化流程

```c
void AD7606_StartRecord_200kSPS(uint32_t sample_freq)
{
    // 1. 初始化AD7606
    AD7606_Reset();
    HAL_Delay(1);
    
    // 2. 配置过采样和量程
    AD7606_SetOS(AD_OS_NO);      // 无过采样
    AD7606_SetInputRange(0);     // ±5V
    
    // 3. 启动第一次转换（填充流水线）
    AD7606_StartConvst();
    HAL_Delay(1);  // 等待第一次转换完成
    
    // 4. 初始化FIFO
    g_tAD.usRead = 0;
    g_tAD.usWrite = 0;
    
    // 5. 配置定时器
    bsp_TIMx_Configuration();
    bsp_SET_TIMx_FREQ(sample_freq);
}
```

### 4.3 定时器配置（200kSPS）

```c
void bsp_SET_TIMx_FREQ(uint32_t _ulFreq)
{
    TIM_HandleTypeDef htim;
    uint32_t tim_clk = 240000000;  // H743定时器时钟（假设APB1=240MHz）
    uint32_t prescaler, period;
    
    // 计算分频和周期
    prescaler = 1;  // 最小分频
    period = tim_clk / _ulFreq;
    
    htim.Instance = TIMx;
    htim.Init.Prescaler = prescaler - 1;
    htim.Init.Period = period - 1;
    htim.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    
    HAL_TIM_Base_Init(&htim);
    HAL_TIM_Base_Start_IT(&htim);
}
```

---

## 五、性能对比

### 5.1 不同方案的性能

| 方案 | 读取方式 | 读取时间 | 最大采样频率 | 是否需要BUSY |
|------|---------|---------|-------------|--------------|
| **方案1（单DOUT）** | 单SPI阻塞 | 35μs | ~28 kSPS | ❌ 不需要 |
| **方案1（双DOUT）** | 双SPI DMA | 4-5μs | ~200 kSPS | ❌ 不需要 |
| **方案2（并口）** | FMC并行 | <1μs | >200 kSPS | ✅ 需要 |

### 5.2 中断开销分析

**STM32H743中断响应时间：**
- 中断延迟：约0.1-0.5μs（取决于系统负载）
- 函数调用开销：约0.1-0.2μs
- 总开销：约0.2-0.7μs

**对于200kSPS（5μs周期）：**
- 中断开销占比：0.7/5 = 14%
- **可接受，但需要优化代码减少开销**

---

## 六、优化建议

### 6.1 代码优化

1. **使用内联函数**：减少函数调用开销
2. **使用DMA**：减少CPU占用
3. **优化FIFO操作**：使用位运算代替取模
4. **减少中断中的计算**：只做必要的数据搬运

### 6.2 硬件优化

1. **必须使用双DOUT**：DOUTA + DOUTB
2. **SPI时钟设置为15MHz**：平衡速度和稳定性
3. **使用DMA传输**：减少CPU开销
4. **优化PCB布局**：减少信号延迟

### 6.3 系统优化

1. **提高定时器中断优先级**：避免被其他中断打断
2. **关闭不必要的全局中断**：减少中断嵌套
3. **使用DMA完成中断**：进一步减少CPU负载

---

## 七、实际测试建议

### 7.1 测试步骤

1. **先测试单DOUT方案**：验证基本功能
2. **测量实际读取时间**：使用示波器测量CS低电平时间
3. **逐步提高采样频率**：找到最大稳定频率
4. **切换到双DOUT方案**：验证200kSPS可行性
5. **优化代码**：根据实测结果优化

### 7.2 关键指标

- **CS低电平持续时间**：应 ≤ 5μs（200kSPS）
- **定时器中断周期稳定性**：使用示波器测量CONVST周期
- **FIFO溢出率**：监控FIFO是否溢出
- **数据完整性**：检查读取的数据是否正确

---

## 八、总结

### ✅ 方案1可以实现200kSPS的条件：

1. ✅ **必须使用双DOUT线**（DOUTA + DOUTB）
2. ✅ **必须使用DMA传输**（减少CPU开销）
3. ✅ **必须优化中断代码**（减少开销）
4. ✅ **SPI时钟设置为15MHz**（平衡速度和稳定性）
5. ✅ **提高定时器中断优先级**（避免被打断）

### ⚠️ 注意事项：

1. ⚠️ **第一次读取是无效数据**：需要先启动一次转换
2. ⚠️ **中断开销需要考虑**：约0.5-1μs
3. ⚠️ **FIFO大小要足够**：避免数据丢失
4. ⚠️ **系统负载要低**：避免其他任务影响采样

### 📝 推荐配置：

- **采样频率**：≤ 180kSPS（留有余量）
- **SPI时钟**：15 MHz
- **中断优先级**：最高（或次高）
- **FIFO大小**：至少8KB（8通道 × 2字节 × 512样本）

---

**详细分析请参考：**
- `AD7606_SPI_200kSPS可行性分析.md`
- `SPI_200kSPS快速配置.md`

